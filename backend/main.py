# --- FINAL MONOLITH FLASK VERSION (Serving API and Frontend) ---
import os
import json
import re
from io import BytesIO
from flask import Flask, jsonify, send_file, request, send_from_directory, Response
from flask_cors import CORS

# Load environment variables FIRST (Recommended)
# from dotenv import load_dotenv
# load_dotenv()

# We need the following imports to initialize Vertex AI/GenAI clients in service files
import vertexai
from services import marketing_copilot, brand_studio, audio_story

# --- 1. FLASK APP INITIALIZATION ---
# Configure Flask to serve the React 'build' directory
# Assuming the React build will be located at `kalakriti-ai/frontend/build`
app = Flask(__name__, 
            static_folder='frontend/build/static',
            template_folder='frontend/build')

# Since the frontend will be served by the same Flask instance (same origin), 
# CORS is technically not required for the API endpoints, but we keep a generic CORS 
# setup on the app just to be safe in dev mode.
CORS(app) 

# Initialize Vertex AI (still required for the service modules)
try:
    GCP_PROJECT_ID = os.getenv("GCP_PROJECT_ID", "kalakriti-ai")
    GCP_REGION = os.getenv("GCP_REGION", "us-central1")
    vertexai.init(project=GCP_PROJECT_ID, location=GCP_REGION)
    print(f"DEBUG: Vertex AI initialized for project {GCP_PROJECT_ID} in {GCP_REGION}")
except Exception as e:
    print(f"DEBUG: Failed to initialize Vertex AI: {e}")
    # Application continues for local development even if AI init fails, but logging error.

# --- 2. SERVING THE FRONTEND (MONOLITH) ---
# This route must catch all paths that don't match an API endpoint to serve the index.html.
@app.route('/', defaults={'path': ''})
@app.route('/<path:path>')
def serve_frontend(path):
    """Serve the main React index.html and handle static files/client-side routing."""
    # Check if the requested path is a specific static file (like a JS/CSS chunk)
    if path != "" and os.path.exists(os.path.join(app.static_folder, path)):
        return send_from_directory(app.static_folder, path)
    
    # Check if the requested path is in the main build folder (like favicon.ico or logo files)
    if path != "" and os.path.exists(os.path.join(app.template_folder, path)):
        return send_from_directory(app.template_folder, path)
        
    # Serve the main index.html for the React SPA
    return send_from_directory(app.template_folder, 'index.html')


# --- 3. API ENDPOINTS (COPIED LOGIC, NOW USING @app.route) ---

@app.route('/api/generate-marketing-kit', methods=['POST'])
def generate_marketing_kit_route():
    if 'image' not in request.files or 'audio' not in request.files:
        return jsonify({"error": "Missing image or audio file."}), 400

    image_content = request.files['image'].read()
    audio_content = request.files['audio'].read()

    try:
        generated_kit_str = marketing_copilot.generate_text_for_art(image_content, audio_content)
        
        if not generated_kit_str or not generated_kit_str.strip():
            return jsonify({"error": "No content generated by AI model."}), 500
        
        cleaned_str = re.sub(r'^```json\n|\n```$', '', generated_kit_str, flags=re.MULTILINE).strip()
        generated_kit_json = json.loads(cleaned_str)
        return jsonify(generated_kit_json), 200
    except json.JSONDecodeError as e:
        return jsonify({"error": f"Invalid JSON response from AI: {e}"}), 500
    except Exception as e:
        return jsonify({"error": f"Internal server error: {e}"}), 500

@app.route('/api/generate-brand-kit', methods=['POST'])
def generate_brand_kit_route():
    if 'images' not in request.files:
        return jsonify({"error": "No image files found."}), 400
    image_files = request.files.getlist('images')
    if not image_files or image_files[0].filename == '':
        return jsonify({"error": "No selected image files."}), 400
    image_contents = [file.read() for file in image_files]
    try:
        generated_kit_str = brand_studio.generate_brand_kit(image_contents)
        if not generated_kit_str or not generated_kit_str.strip():
            return jsonify({"error": "No content generated by AI model."}), 500
        generated_kit_json = json.loads(generated_kit_str)
        return jsonify(generated_kit_json), 200
    except json.JSONDecodeError as e:
        return jsonify({"error": f"Invalid JSON response from AI: {e}"}), 500
    except Exception as e:
        return jsonify({"error": f"Internal server error: {e}"}), 500

@app.route('/api/generate-audio-story', methods=['POST'])
def generate_audio_story_route():
    if 'audio' not in request.files:
        return jsonify({"error": "Missing audio file."}), 400
    audio_content = request.files['audio'].read()
    try:
        final_audio_bytes = audio_story.create_audio_story(audio_content)
        if final_audio_bytes:
            return send_file(
                BytesIO(final_audio_bytes),
                mimetype='audio/mpeg',
                as_attachment=True,
                download_name='kalakriti_story.mp3'
            )
        else:
            return jsonify({"error": "Failed to create audio story."}), 500
    except Exception as e:
        return jsonify({"error": f"Internal server error: {e}"}), 500

if __name__ == '__main__':
    # Flask will now serve both the frontend and API on http://127.0.0.1:5000
    app.run(host='127.0.0.1', port=5000, debug=True)
